# 微服务

## 微服务简介
单体应用的问题：

- 部署效率低下
- 团队协作开发成本高
- 系统高可用性差
- 线上发布变慢

**服务化**就是将传统单机应用中通过 JAR 包依赖产生的本地方法调用，改造成通过 RPC 接口产生的远程方法调用。    

微服务的特点：

- 服务拆分粒度更细
- 服务独立部署
- 服务独立维护
- 服务治理能力要求高

从单体应用迁移到微服务架构时需要面对的几个问题：

- 服务如何定义？通过接口
- 服务如何发布和订阅？注册中心
- 服务如何监控？业务埋点、数据收集、数据处理、数据展示
- 服务如何治理？降级、限流、熔断等
- 故障如何定位？标记用户请求，在多个依赖的服务系统中传递，串联所有路径

微服务架构中，服务调用主要依赖：

- 服务描述：RESTFul API、XML 配置、IDL 文件
- 注册中心
    - 服务提供者启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务
    - 服务消费者启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需的服务
    - 注册中心返回服务提供者地址列表给服务消费者
    - 当服务提供者发生变化，比如有节点新增或销毁，注册中心将变更通知给服务消费者
    
- 服务框架
    - 服务通信采用什么协议？TCP、UDP、HTTP
    - 数据传输采用什么方式？同步还是异步、单连接还是多路复用
    - 数据压缩采用什么格式？JSON、JAVA 对象序列化、PB
- 服务监控
    - 指标收集，将每次服务调用的请求耗时和成功与否收集起来并上传
    - 数据处理，计算每秒服务请求量、平均耗时以及成功率等指标
    - 数据展示 ，展示在 Dashboard 面板上，每隔 10s 等间隔自动刷新，用作业务监控和报警
- 服务追踪
    - 服务消费者发起调用前，本地按规则生成一个 requestId，作为请求参数的一部分传递给服务提供者
- 服务治理
    - 常见故障：单机故障；单 IDC 故障；依赖服务不可用

## 发布和引用服务
- RESTFul API：跨语言平台，组织内外皆可，缺点是使用 HTTP 通信协议，性能较 TCP 差
- XML 配置：JAVA 平台，一般用作组织内部，缺点是不支持跨语言平台
- IDL 文件：跨语言平台（例如 Java 和 PHP 服务间调用），组织内外皆可，缺点是修改或删除PB字段不能向前兼容

## 注册和发现服务
**开源注册中心 ZooKeeper。**    
在微服务架构下，主要有三种角色：服务提供者（RPC Server）、服务消费者（RPC Client）和服务注册中心（Registry）。

- RPC Server 提供服务，在启动时，根据服务发布文件 server.xml 中的配置的信息，向 Registry 注册自身服务，并向 Registry 定期发送心跳汇报存活状态。
- RPC Client 调用服务，在启动时，根据服务引用文件 client.xml 中配置的信息，向 Registry 订阅服务，把 Registry 返回的服务节点列表缓存在本地内存中，并与 RPC Sever 建立连接。
- 当 RPC Server 节点发生变更时，Registry 会同步变更，RPC Client 感知后会刷新本地内存中缓存的服务节点列表。
- RPC Client 从本地缓存的服务节点列表中，基于负载均衡算法选择一台 RPC Sever 发起调用。

注册中心的基本 API：
- 服务注册/反注册接口
- 心跳汇报接口
- 服务订阅接口
- 服务变更查询接口

注册中心一般都是采用**集群部署**来保证高可用性，并通过分布式一致性协议来确保集群中不同节点之间的数据保持一致。    

注册中心必须具备服务**健康状态检测功能**，保证注册中心中保存的服务节点都是可用的。ZooKeeper 基于客户端和服务端的长连接和会话超时控制机制，来实现服务健康状态检测。

注册中心可以提供一个**白名单机制**，只有添加到注册中心白名单内的 RPC Server，才能够调用注册中心的注册接口，这样的话可以避免测试环境中的节点意外跑到线上环境中去。

## RPC 远程服务调用
- **通信框架**。它主要解决客户端和服务端如何建立连接、管理连接以及服务端如何处理请求的问题。
- **通信协议**。它主要解决客户端和服务端采用哪种数据传输协议的问题。
- **序列化和反序列化**。它主要解决客户端和服务端采用哪种数据编解码的问题。

### 网络连接
- HTTP 协议
- Socket 通信

客户端服务端建联后，可能遇到网络闪断、连接超时、服务端宕机等异常，处理手段：

- 链路存活检测：客户端定时发心跳检测（一般通过 ping 请求），如果服务端连续 n 次或超过规定时间没回复，则认定链路失效，需要重连
- 断连重试：客户端主动关闭、服务器宕机或网络闪断都可能导致连接断开，需要重连。但一般等固定间隔后重连，防止服务端回收不及时，导致服务端连接占满

### 服务端处理请求
- 同步阻塞（BIO）：客户端每发一个请求，服务端就生成一个线程去处理。**适合连接数比较小的场景。**
- 同步飞阻塞（NIO）：客户端每发一个请求，服务端通过 IO 多路复用技术，将多个 IO 阻塞复用到同一个 select 的阻塞上，实现单线程同时处理多个客户端请求。**适用于连接数比较多并且请求消耗比较轻的业务场景，比如聊天服务器。**
- 异步非阻塞（AIO），客户端发请求后立刻返回，服务端 IO 操作完成后通知客户端。**适用于连接数比较多而且请求消耗比较重的业务场景，比如涉及 I/O 操作的相册服务器。**编程难度最大。

### 序列化和反序列化
常用的序列化方式分为两类：文本类如 XML/JSON 等，二进制类如 PB/Thrift 等。

## 微服务监控
### 监控对象
- 用户端监控。通常是指业务直接对用户提供的功能的监控。
- 接口监控。通常是指业务提供的功能所依赖的具体 RPC 接口的监控。
- 资源监控。通常是指某个接口依赖的资源的监控。
- 基础监控。通常是指对服务器本身的健康状况的监控。主要包括 CPU 利用率、内存使用量、I/O 读写量、网卡带宽等。

### 监控指标
- 请求量。请求量监控分为两个维度，一个是实时请求量，一个是统计请求量。
- 响应时间。大多数情况下，可以用一段时间内所有调用的平均耗时来反映请求的响应时间。
- 错误率。错误率的监控通常用一段时间内调用失败的次数占调用总次数的比率来衡量。

### 监控维度
- 全局维度
- 分机房维度
- 单机维度
- 时间维度
- 核心维度

### 监控系统原理
监控系统主要包括四个环节：数据采集、数据传输、数据处理和数据展示。

数据采集方式：

- 服务主动上报，在业务代码或者服务框架里加入数据收集代码逻辑，在每一次服务调用完成后，主动上报服务的调用信息。
- 代理收集，通过服务调用后把调用的详细信息记录到本地日志文件中，然后再通过代理去解析本地日志文件，然后再上报服务的调用信息。

数据聚合通常有两个维度：

- 接口维度聚合，这个维度是把实时收到的数据按照接口名维度实时聚合在一起，这样就可以得到每个接口的实时请求量、平均耗时等信。
- 机器维度聚合，这个维度是把实时收到的数据按照调用的节点维度聚合在一起，这样就可以从单机维度去查看每个接口的实时请求量、平均耗时等信息。

聚合后的数据需要持久化到数据库中存储，所选用的数据库一般分为两种：

- 索引数据库，比如 Elasticsearch，以倒排索引的数据结构存储，需要查询的时候，根据索引来查询。
- 时序数据库，比如 OpenTSDB，以时序序列数据的方式存储，查询的时候按照时序如 1min、5min 等维度来查询。

数据展示：

- 曲线图
- 饼状图
- 格子图

## 服务追踪
### 作用
- 优化系统瓶颈（找到系统瓶颈并优化）
- 优化调用链路（分析调用链路是否合理）
- 生成网络拓扑（生成系统网络拓扑图，标记详细信息）
- 透明传输数据（传递用户数据，例如 ABTest 的开关逻辑）

### 核心原理
通过一个全局唯一的 ID 将分布在各个服务节点上的同一次请求串联起来，从而还原原有的调用关系，可以追踪系统问题、分析调用数据并统计各种系统指标。

- traceId：用户的请求进入系统后，会在 RPC 调用网络的第一层生成一个全局唯一的 traceId，并且会随着每一层的 RPC 调用，不断往后传递
- spanId：用于标识一次 RPC 调用在分布式请求中的位置
- annotation：用于业务自定义埋点数据

traceId 是用于串联某一次请求在系统中经过的所有路径，spanId 是用于区分系统不同服务之间调用的先后关系，而 annotation 是用于业务自定义一些自己感兴趣的数据，在上传 traceId 和 spanId 这些基本信息之外，添加一些自己感兴趣的信息。

### 架构实现
- 数据采集层
- 数据处理层
	- 实时数据处理
	- 离线数据处理 
- 数据展示层
	- 调用链路图
	- 调用拓扑图 
