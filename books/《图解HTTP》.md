## 第一章 了解 Web 及网络基础
#### TCP/IP 的分层
HTTP 请求分层流程：

1. 客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求
2. 为了传输方便，在传输层（TCP 协议）把应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层
3. 网络层（IP 协议）增加作为通信目的地的 MAC 地址后转发给链路层。这时候，发往网络的通信请求就准备齐全了
4. 接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才算真正接收到客户端发送过来的 HTTP 请求

**封装**：发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层就会把对应的首部去掉。

###### TCP 三次握手
1. 发送端首先发送一个带 SYN 标志的数据包给对方
2. 接收端收到后，回传一个带有 SYN/ACK 标志的数据包以 示传达确认信息
3. 最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。

## 第二章 简单的 HTTP 协议
#### HTTP 是不保存状态的协议
HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，引入了 **Cookie技术**，Cookie 可以管理状态。

#### HTTP/1.1 中可以使用的方法
- GET：获取资源。获取指定的资源经服务器端解析后返回响应内容。（如果是文本就原样返回，如果是 CGI 网关，就返回执行后的输出结果）
- POST：传输实体
- PUT：传输文件
- HEAD：获得报文首部（用于确认 URI 的有效性及资源更新日期等）
- DELETE：删除文件，与 PUT 相反
- OPTIONS：询问支持的方法。查询针对请求 URI 指定的资源支持的方法
- TRACE：追踪路径，一般不用
- CONNECT：要求用隧道协议连接代理。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输

#### 持久连接节省通信量
HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。    
为了解决这个问题，HTTP/1.1 接入了持久连接（HTTP keep-alive），只要任一端没有明确提出断开连接，就保持 TCP 连接状态。

#### 使用 Cookie 管理状态
HTTP 是无状态协议，不管理之前发生的请求和响应状态，无法根据之前的状态进行本次的请求处理，因为**如果让服务器管理全部客户端的状态会增加消耗**。    
Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。    

- 服务端发送的响应报文内添加一个叫 Set-Cookie 的首部字段信息，通知客户端保存 Cookie
- 客户端下一次往该服务端发送请求时，客户端会自动在请求报文中加入 Cookie 值
- 服务端检查客户端发送过来的 Cookie 信息，对比之前的记录，得到之前的状态

## 第三章 HTTP 报文内的 HTTP 信息
HTTP 报文大致分为**报文首部**和**报文主体**两块，两者由最初的空行（CR+LF）来划分。
报文首部主要包括：

- 请求行：包含请求的方法，请求 URI 和 HTTP 版本
- 状态行：包含表明响应结果的状态码，原因短语和 HTTP 版本
- 首部字段：包含表示请求和响应的各种条件和属性的各类首部。一般有4种
  - 通用首部
  - 请求首部
  - 响应首部
  - 实体首部
- 其他：可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）

## 第四章 返回结果的 HTTP 状态码
|     | 类别                         | 原因短语                |
| --- |:---------------------------:| ----------------------:|
| 1XX | Informational(信息性状态码)   | 接收的请求正在处理        |
| 2XX | Success(成功状态码)           | 请求正常处理完毕         |
| 3XX | Redirection(重定向状态码)     | 需要进行附加操作以完成请求 |
| 4XX | Client Error(客户端错误状态码) | 服务器无法处理请求       |
| 5XX | Server Error(服务器错误状态码) | 服务器处理请求出错       |

## 第五章 与 HTTP 协作的 Web 服务器
HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。    
如果一台服务器内托管了多个域名，IP 协议收到请求时就需要区分到底访问哪个域名，所以**必须在发送 HTTP 请求时，在 Host 首部内完整指定主机名或域名的 URI**。

#### 通信数据转发程序：代理、网关、隧道
###### 代理
代理是一种有转发功能的应用程序，扮演了服务器与客户端的“中间人”角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器的响应并转发给客户端。    
代理主要用途包括：

- 利用缓存技术减少网络带宽的流量
- 组织内部针对特定网站的访问控制
- 获取访问日志

###### 网关
网关是转发其他服务器通信数据的服务器，接收客户端请求，它就像拥有资源的源服务器一样对请求进行处理，客户端可能甚至不会察觉自己的通信目标是一个网关。    
网关可以访问数据库，可以与其他系统联通等等，总之，**网关能使通信线路上的服务器提供非 HTTP 协议服务**。

###### 隧道
隧道是在相隔甚远的客户端与服务器之间进行中转，保持双方通信连接的应用程序。    
隧道可用 SSL 等加密手段进行通信，确保客户端与服务器能安全的通信。    
隧道本身不会解析 HTTP 请求，并且会在通信双方断开连接时结束。

## 第六章 HTTP 首部
- HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接，要想在旧版本的 HTTP 协议上开启持续连接，需要指定 *Connection: Keep-Alive*。

#### 为 Cookie 服务的首部字段
Cookie 的工作机制是用户识别及状态管理。    
Cookie 可校验有效期、发送方的域、路径、协议等信息。

## 第七章 确保 Web 安全的 HTTPS
#### HTTP 的缺点
1. 通信使用明文（不加密），内容可能被窃听
2. 不验证通信方的身份，因此有可能遭遇伪装
3. 无法证明报文的完整性，有可能已经遭篡改

##### 通信使用明文可能会被窃听
###### TCP/IP 是可能被窃听的网络
收集互联网上流动的数据包（帧）即可实现窃听，至于解析工作，可以交给**抓包工具**或**嗅探工具**，例如 Wireshark。

###### 加密处理防止窃听
- 通信加密：通过 SSL 组合加密 HTTP（即 HTTPS）
- 内容加密：不同于 SSL 将这个通信线路加密处理，内容仍可能被篡改

##### 不验证通信方的身份就可能遭遇伪装
任何人都可以发起请求，服务端接收到请求后，无论对方是谁都会响应。

- 请求发出去的目标 Web 服务器可能是伪装的
- 响应返回的客户端可能是伪装的
- Web 服务器无法确定请求方的权限
- 无意义的请求也照单全收，无法阻止海量请求下的 Dos 攻击

##### 无法验证报文的完整性，可能已遭篡改
可能遭遇**中间人攻击**

###### 如何防止篡改
HTTP 协议有确认报文完整性的方法，但事实上不便捷，不可靠。     
其中常用的是 MD5 和 SHA-1 等散列值校验，但这些值本身被改写的话，用户也没法意识到。

#### HTTP + 加密 + 认证+ 完整性保护 = HTTPS
##### HTTPS 是身披 SSL 外壳的 HTTP
之前，HTTP 直接和 TCP 通信，当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信。    
采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。    
SSL 独立于 HTTP 协议，所以不光是 HTTP，其他应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。    
**SSL 是当今世界应用最广泛的网络安全技术**。

##### 相互交换密钥的公开密钥加密技术
###### 对称加密及问题
加解密都用同一个密钥的方式叫对称加密。    
**在互联网上转发密钥时，如果通信被监听，密钥就可能落入攻击者之手，就失去了加密的意义。**

###### 非对称加密
非对称加密有两把密钥，一把叫**私钥**，一把叫**公钥**。    
使用非对称加密，发送密文的一方使用对方的公钥进行加密，对方收到加密信息后，再使用自己的私钥进行解密。    
这样不需要发送用来解密的私钥，也不必担心公钥被攻击者窃听而盗走。

###### HTTPS 采用混合加密机制
对称加密的安全性不够，非对称加密的处理速度慢，针对这个情况，HTTPS 组合使用这两种加密方式：**在交换密钥环节使用非对称加密，之后的建立通信交换报文阶段则使用对称加密**。

###### 证明公钥正确性的证书
公钥可能在传输途中被替换，为了解决这个问题，可以使用数字证书认证机构（CA，Certificate Authority）和其他相关机构颁发的公钥证书。    
**原理**：    
1. 服务器把自己的公钥登录至数字证书认证机构
2. 数字证书认证机构用自己的私钥向服务器的公钥进行数字签名并颁发公钥证书
3. 客户端拿到服务器的公钥，使用数字证书认证机构的公钥（通常已经植入多数浏览器的发布版本），向数字证书认证机构验签，以确认服务器公钥的真实性
4. 使用服务器公钥进行通信

###### HTTPS 的安全通信机制
1. 客户端发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 版本、加密组件列表（加密算法和密钥长度）
2. 服务端可进行 SSL 通信时，会以 Service Hello 报文作为应答。和客户端一样，报文中包含 SSL 版本以及加密组件。服务端的加密组件内容是从接收到的客户端加密组件里筛选出来的
3. 服务端发送 Certificate 报文，报文中包含公钥证书
4. 服务端发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协议结束
5. SSL 第一次握手结束后，服务端以 Client Key Exchange 报文作为回应。报文中包含加密通信使用的一种被称为 Pre-master secret 随机密码串。**这个报文用步骤3中的公钥进行加密**
6. 客户端发送 Change Cipher Spec 报文，报文会提示服务器，在此报文之后通信会采用 Pre-master secret 密钥加密
7. 客户端发送 Finished 报文。该报文包含连接至今的全部报文的整体校验值。这次握手是否能成功，要以服务器能否正确解密该报文为准
8. 服务器发送 Change Cipher Spec 报文
9. 服务器发送 Finished 报文
10. 服务器和客户端的 Finished 报文交换完毕后，SSL 连接算建立完成。通信会受 SSL 保护
11. 始进行应用层协议通信，即发送 HTTP 请求
12. 最后由客户端断开连接。断开连接时，发送 close_notify 报文，之后发送 TCP FIN 报文来关闭 TCP 通信

###### HTTPS 的弊端
1. SSL 消耗网络资源，会让通信变慢
2. 服务端和客户端需要对数据进行加解密，消耗 CPU 和内存资源
3. 购买证书会增加开销

## 第八章 确认访问用户身份的认证
某些网站需要让特定的人浏览，就需要认证机制。

#### 何为认证
常见的核对信息：

1. 密码：仅限本人知道的字符串
2. 动态令牌：仅限本人持有的设备内显示的一次性密码
3. 数字证书：仅限本人（终端）持有的信息
4. 生物认证：质问或虹膜等本人生理信息
5. IC卡等：仅限本人持有的信息

HTTP 使用的认证方式：

1. BASIC 认证（基本认证）
2. DIGEST 认证（摘要认证）
3. SSL 客户端认证
4. FormBase 认证（基于表单认证）

#### BASIC 认证
BASIC 认证(基本认证)是从 HTTP/1.0 就定义的认证方式，现在仍有一部分网站会使用这种认证方式。

1. 请求资源需要 BASIC 认证，服务器会返回 401 Authorization Required（其中带 WWW- Authenticate 首部字段）响应。
2. 客户端收到 401 响应，需要将用户 ID 和密码发送给服务器。发送的字符串内容是用户 ID 加密码，中间用冒号（:）连接，再经 Base64 编码。
3. 服务端接收包含首部字段 Authenticate 的请求，会对认证信息进行校验，校验通过则返回请求内容。

**BASIC 认证采用 Base64 编码，并不是加密，非常不安全。**

#### DIGEST 认证
DIGEST 认证的出现是为了弥补 BASIC 认证的弱点。

1. 服务器会返回 401 Authorization Required（其中带 WWW- Authenticate 首部字段）响应，而首部字段 WWW-Authenticate 内必须包含 realm 和 nonce 这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。
2. 接收到 401 状态码的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息。首部字段 Authorization 内必须包含 username、realm、nonce、uri 和 response 的字段信息。
 - realm 和 nonce 就是之前从服务器接收到的响应中的字段
 - username 是 realm 限定范围内可进行认证的用户名
 - uri(digest-uri)即 Request-URI 的值，但考虑到经代理转发后 Request-URI 的值可能被修改，因此事先会复制一份副本保存在 uri 内
 - esponse 也可叫做 Request-Digest，存放经过 MD5 运算后的密码字符串，形成响应码

3. 服务端接收包含首部字段 Authenticate 的请求，会对认证信息进行校验，校验通过则返回请求内容。

DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 的客户端认证相比仍旧很弱。DIGEST 认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。

#### SSL 客户端认证
SSL 客户端认证是借由 HTTPS 的**客户端证书**完成认证的方式。

1. 接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书。
2. 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。
3. 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。#### 基于表单认证
客户端会向服务器上的 Web 应用程序发送登录信息（Credential），按登录信息的验证结果认证。
**通过服务器端的 Web 应用，将客户端发送过来的用户 ID 和密码与之前登录过的信息做 匹配来进行认证。**

###### 认证多数为基于表单认证
由于使用上的便利性及安全性问题，HTTP 协议标准提供的 BASIC 认证和 DIGEST 认证几乎不怎么使用。另外，SSL 客户端认证虽然具有高度的安全等级，但因为导入及维持费用等问题，还尚未普及。###### Session 管理及 Cookie 应用
基于表单认证的标准规范尚未有定论，一般会使用 Cookie 来管理 Session（会话）    
基于表单认证本身是通过服务器端的 Web 应用，将客户端发送过来的用户 ID 和密码与之前登录过的信息做 匹配来进行认证的。但 HTTP 是无状态协议，之前认证成功的用户无法通过协议层保存。所以会使用 Cookie 来管理 Session，以弥补 Http 协议中不存在的状态管理功能。

1. 客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是用 POST 方法把请求发送给服务器。
2. 服务端发放用来识别用户的 Session ID，通过验证客户端发送的登录信息进行身份验证，然后把用户认证状态与 Session ID 绑定并记录在服务端。     
向客户端发响应，会在首部字段 Set-Cookie 内写入 Session ID（如 PHPSESSION=028a8c...）。    
然而，如果 Session ID 被盗，对方就可以伪装成用户进行恶意操作。因此，Session ID 应使用难以推测的字符串，而且服务端也需要进行有效期的管理。
3. 客户端收到服务端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务端发送请求时，将 Cookie 内容带上，这样 Session ID 也会一并发给服务器，服务端可以进行身份校验。## 第九章 基于 HTTP 的功能追加协议#### 消除 HTTP 瓶颈的 SPDY
1. 多路复用：单一 TCP 连接可以无限制处理多个 HTTP 请求
2. 请求优先级：不仅可以无限制并发处理请求，还可以给请求分配优先级
3. 压缩 HTTP 首部：压缩 HTTP 请求和响应的首部，这样通信产生的数据量变少
4. 推送功能：支持服务端主动想客户端推送数据
5. 服务器提示功能：服务器可以主动提示客户端请求所需的资源

#### 使用浏览器进行全双工通信的 WebSocket
一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。    
通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式的数据。    由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端，而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。

- 推送：支持服务端向客户端推送数据
- 减少通信量：一直保持连接，减少了每次连接时的开销，同时首部信息变小，通信量变少

## 第十章 构建 Web 内容的技术## 第十一章 Web 的攻击技术
#### 在客户端篡改请求
**请求**：在 HTTP 请求报文内加载攻击代码，就能发起对 Web 应用的攻击。通过 URL 查询字段或表单、HTTP 首 部、Cookie 等途径把攻击代码传入，若这时 Web 应用存在安全漏洞，那内部信息就会遭到窃取，或被攻击者拿到管理权限。   
**响应**：在 Web 应用中，从浏览器那接收到的 HTTP 请求的全部内容，都可以在客户端自由地变更、篡改。

#### 以服务器为目标的主动攻击
1. 跨站脚本攻击    
2. SQL 注入攻击    
3. OS 命令注入攻击    
4. HTTP 首部注入攻击
5. 邮件首部注入攻击
6. 目录遍历攻击
    