## 第一章 并发编程的挑战
#### 1.1 上下文切换
CPU 分配给各个线程时间，通过时间片分配算法来循环执行任务，时间片一般是**几十毫秒（ms）**，**所有任务从保存到再加载的过程就是一次上下文切换**。    
实践中应避免创建不需要的线程，太多线程处于 WAITING 状态会增加上下文切换的次数和时长。

#### 1.2 死锁
避免死锁的几个常见方法：

- 避免一个线程同时获得多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
- 尝试使用定时锁，使用 lock.tryLock(time) 来替代使用内部锁机制
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

#### 1.3 资源限制的挑战
并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。

- 对于硬件资源限制，可以考虑使用集群并发执行程序
- 对于软件资源限制，可以考虑使用资源池将资源复用

#### 建议多使用JDK并发包提供的并发容器和工具类来解决并发问题，因为这些类都已经过充分的测试和优化。

## 第二章 Java 并发机制的底层实现原理
#### 2.1 volatile 的应用
volatile 是轻量级的 synchronized，在并发处理中保证**一个线程修改一个共享变量的时候，另一个线程能读到修改的值**。    
volatile 变量修饰符使用恰当的话，比 synchronized 使用和执行成本更低，因为它不会引起程序上下文的切换和调度。

###### 2.1.1 volatile 定义与原理实现
如果一个字段被声明为 volatile，那么 Java 线程内存模型确保所有的线程看到这个变量的值是一致的。    
volatile 两个实现原则：    

1. Lock前缀指令会引起处理器缓存回写到内存
2. 一个处理器缓存回写到内存会导致其他处理器的缓存失效

#### 2.2 synchronized 的实现原理与应用
一个线程试图访问同步代码块时，它首先必须得到锁；退出或抛出异常时必须释放锁。
java 中每一个对象都可以作为锁，具体有3种形式：

- 对于普通同步方法，锁是当前实例对象
- 对于静态同步方法，锁是当前类的 Class 对象
- 对于同步方法块，锁是 Synchronized 括号里配置的对象

#### 2.3 原子操作
从 Java1.5 开始，JDK的并发包提供一些类支持原子操作，如 AtomicBoolean、AtomicInteger 和 AtomicLong。这些原子包装类还提供了一些有用的工具方法，比如以原子的方式将当前值自增 1 和自减 1。

## 第三章 Java 内存模型
#### 3.1 Java 内存模型的基础
###### 3.1.1 并发编程模型的两个关键问题
线程之间的通信机制有两种：

1. 共享内存
2. 消息传递

Java 并发采用的是共享内存模型。

###### 3.1.2 Java 内存模型的抽象结构
java 中，所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。    
Java 线程之间的通信由 Java 内存模型（简称 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。    
抽象角度看，JMM 定义了线程和主内存之间的抽象关系：**线程之间的共享变量存储在主内存（ Main Memory ）中，每个线程都有一个私有的本地内存（ Local Memory ），本地内存中存储了该线程以读/写共享变量的副本。**    
    
如果线程 A 与线程 B 之间要通信的话，必须经历2个步骤。
1）线程 A 把本地内存更新过的共享变量刷新到主内存中    
2）线程 B 到主内存中去读取线程 A 之前已更新过的共享变量    
    
JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 Java 程序员提供内存可见性保证。

#### 3.4 Volatile 的内存定义
###### 3.4.1 volatile 的特性
理解 volatile 特性的一个好方法是把对 volatile 变量的单个读/写，看出是使用同一个锁对这些单个读/写操作做了同步。

```java
class VolatileFeaturesExample {
	volatile long v1 = 0L;

	public void set(long l) {
		v1 = l;
	}

	public void getAndIncrement() {
		v1++;
	}

	public long get() {
		return v1;
	}
}
```
等同于下面这段代码：

```java
class VolatileFeaturesExample {
	long v1 = 0L;

	public synchronized void set(long l) {
		v1 = l;
	}

	public void getAndIncrement() {
		long temp = get();
		temp += 1L;
		set(temp);
	}

	public synchronized long get() {
		return v1;
	}
}
```


volatile 写的内存定义是：    
**当写一个 volatile 变量时，JMM 会吧该线程对应的本地内存中的共享变量值刷新到主内存中。**    
volatile 读的内存定义是：
**当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。**








