多线程面试题
==========

# wait 和 sleep 的区别？
wait 会释放锁，而 sleep 一直持有锁。    
wait 通常被用于线程间交互，sleep 通常被用于暂停执行。

# volatile 关键字是什么作用？怎样使用它？它跟 synchronized 方法有什么不同？
volatile 是轻量级的 synchronized，在并发处理中**保证一个线程修改一个共享变量的时候，另一个线程能读到修改的值**。    
根据 Java 内存模型的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU 缓存），操作完成后再把结果从线程本地刷到主存。    
所有对 volatile 变量的读写都会直接刷到主存，即保证了变量的可见性。

# 如何安全终止线程？
- 设置一个 volatile 的标志位来终止线程
- 通过中断操作

# suspend()、resume() 和 stop() 为什么过期？
suspend() 方法调用后，线程不会释放已经占有的资源（比如锁），会引发死锁问题。    
stop() 方法终结一个线程时也不保证资源正常释放。

# 线程间通信？
- volatile 和 synchronized 关键字
- 等待 / 通知机制（*wait() / notify() / notifyAll()*）
- 管道输入 / 输出
- *Thread.join()* 使用

# ThreadLocal 的使用？
通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。    
而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。    
**通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题**。    
使用场景：    

- 实现单个线程单例以及单个线程上下文信息存储，比如交易id等
- 实现线程安全，非线程安全的对象使用ThreadLocal之后就会变得线程安全，因为每个线程都会有一个对应的实例
- 承载一些线程相关的数据，避免在方法中来回传递参数

# ConcurrentHashMap 的实现原理与使用
HashMap 在并发编程中可能导致死循环，而使用线程安全的 HashTable 效率又底下，所有有了 ConcurrentHashMap。    
ConcurrentHashMap 使用锁分段技术：**首先将数据分成一段一段存储，然后每一段数据配一把锁，当一个线程占用锁访问其中一段数据时，其他段数据也能被其他线程访问**。

# Lock 接口比 synchronized 块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？

lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像 ConcurrentHashMap 这样的高性能数据结构和有条件的阻塞。    
当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。

# 有三个线程T1，T2，T3，怎么确保它们按顺序执行？
可以用线程类的 join() 方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。