Android 性能优化
==========
# 内存泄漏

## 引用类型
| 级别 | 回收时机 | 用途 | 生存时间 |
| ------ | ------ | ------ | ------ |
| 强 | 从来不会 | 对象的一般状态 | JVM停止运行时终止 |
| 软 | 在内存不足时 | 联合ReferenceQueue构造有效期短/占内存大/生命周期长的对象的二级高速缓冲器（内存不足才清空）| 内存不足时终止 |
| 弱 | 在垃圾回收时 | 联合ReferenceQueue构造有效期短/占内存大/生命周期长的对象的一级高速缓冲器（系统发生gc则清空） | gc运行后终止 |
| 虚 | 在垃圾回收时 | 联合ReferenceQueue来跟踪对象被垃圾回收器回收的活动 | gc运行后终止 |

## 常见内存泄漏原因
- 单例模式或静态变量引用了 Activity
- 资源未关闭，Receiver（BroadcastReceiver）、Observer（ContentObserver、FileObserver）、Cursor、Callback 等没有 unregister 或者 close 掉
- Handler 发送的 Message 尚未被处理
- Thread 引用了 Activity 对象，同时 run 函数长时间没有结束
- Timer 引用了 Activity 对象，没有 cancel
- Bitmap 没调用 recycle()
- 集合类的泄漏
- 匿名内部类/非静态内部类造成内存泄漏

## 性能优化
#### FPS 优化
- 布局优化：删减布局层级，使用性能较低的 ViewGroup
- 灵活结合 merge 和 include
- 使用 ViewStub
- onDraw() 方法避免执行大量分配对象，不做耗时操作
- 使用 ViewHolder
- 少做 notifyDataSetChanged 操作

#### ListView / RecyclerView 优化
- 使用 ViewHolder 模式来提高效率
- 滑动时停止图片加载或分页加载等

#### 响应速度优化
- 避免在主线程做耗时的操作

#### 线程优化
- 采用线程池，避免程序中存在大量 Thread 

#### 其他优化
- 不要过多的创建对象
- 不要过多使用枚举类，枚举占用内存空间要比整型大
- 常量使用 static final 修饰
- 使用 Android 特有的数据结构
- 适当采用软引用和弱引用
- 采用内存缓存和磁盘缓存
- 尽量采用静态内部类，可避免潜在由于内部类导致的内存泄漏


## 优化案例
### 案例1：管家首次安装启动耗时10秒减至4秒
#### 问题分析
- 插件安装加载耗时长；
- 反序列化全部插件信息；
- 同步回调每个插件的安装和初始化方法；
- 插件安装耗时在数据迁移和数据库读写上。

#### 解决办法
- 将固有插件静态编译进宿主避免启动时大批量动态加载插件信息；
- 将每个插件安装和初始化方法的回调方法中的耗时操作改成**异步**方式；
- 合并全部插件加载时的部分数据库访问操作，通过**批量提交**的方式提高性能。

### 案例2：主界面切换卡顿1秒、各一级页面加载慢
#### 问题分析
- UI主线程太重；
- 在页面onCreate()和onResume()中进行数据初始化操作耗时长。

#### 解决办法
- 用handler或者new thread进行异步化；
- 牺牲一定的UI交互体验。

### 案例3：点击“桌面助手” 3秒后才弹出小浮窗
#### 问题分析
- 前台窗口显示和拉取数据都是异步化；
- onDraw()的时机被系统控制；
- 拉取数据操作优先级高，阻塞了界面显示。

#### 解决办法
- 将拉取数据消息命令延时插入消息队列mHandle.sendMessageDelayed(msg, 100)；
- 提速2秒以上。

### 案例4：列表滑动很卡顿
#### 问题分析
- 拉取图标是同步的；
- 加载图标和刷新任务太频繁。

#### 解决办法
- 异步加载图标；
- 图标下载后缓存至SD卡；
- 滑动过程不加载图标，停下来才加载；
- 每次仅加载包括前屏、当前和后屏3倍屏幕个数的图标；
- 纯色背景和分割线避免使用图片，改为设置ui属性实现类似效果：
 - android:divider="#fffff" 
 - android:dividerHeight="1px“ 

### 案例5：列表下拉绘制次数异常频繁
#### 问题分析
- 下拉刷新移动效果，通过setpadding设置顶部view的间距，会导致重新布局。

#### 解决办法
- 用scrollBy移动函数。
